/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  Address,
  Contract,
  ContractState,
  TestContractResult,
  HexString,
  ContractFactory,
  EventSubscribeOptions,
  EventSubscription,
  CallContractParams,
  CallContractResult,
  TestContractParams,
  ContractEvent,
  subscribeContractEvent,
  subscribeContractEvents,
  testMethod,
  callMethod,
  multicallMethods,
  fetchContractState,
  Asset,
  ContractInstance,
  getContractEventsCurrentCount,
  TestContractParamsWithoutMaps,
  TestContractResultWithoutMaps,
  SignExecuteContractMethodParams,
  SignExecuteScriptTxResult,
  signExecuteMethod,
  addStdIdToFields,
  encodeContractFields,
  Narrow,
} from "@alephium/web3";
import { default as PoolCLContractJson } from "../clamm/PoolCL.ral.json";
import { getContractByCodeHash, registerContract } from "./contracts";
import {
  CurrentPoolInfo,
  FactoryProtectedData,
  FactoryRoles,
  IncentiveKey,
  ModifyLiquidity,
  ModifyLiquidityScriptParams,
  NewStruct,
  NextTick,
  ObservationCL,
  ObservationTP,
  PendingBalance,
  PoolData,
  PoolKey,
  Position,
  PositionKey,
  StakeCLInfo,
  StakerCLData,
  StakerCLIncentive,
  TickInfo,
  TickUpdateInfo,
  AllStructs,
} from "./types";
import { RalphMap } from "@alephium/web3";

// Custom types for the contract
export namespace PoolCLTypes {
  export type Fields = {
    factory: HexString;
    tickSpacing: bigint;
    feePerMil: bigint;
    token0: HexString;
    token1: HexString;
    poolData: PoolData;
    factoryData: FactoryProtectedData;
  };

  export type State = ContractState<Fields>;

  export type SwapEvent = ContractEvent<{
    caller: Address;
    token0: HexString;
    token1: HexString;
    delta0: bigint;
    delta1: bigint;
    sqrtPriceX96: bigint;
    tick: bigint;
    lpFeePerMil: bigint;
  }>;
  export type ModifyLiquidityEvent = ContractEvent<{
    owner: Address;
    token0: HexString;
    token1: HexString;
    tickLower: bigint;
    tickUpper: bigint;
    liquidityDelta: bigint;
    salt: HexString;
  }>;

  export interface CallMethodTable {
    getTWAP: {
      params: CallContractParams<{
        token: HexString;
        startTimestamp: bigint;
        endTimestamp: bigint;
      }>;
      result: CallContractResult<[bigint, bigint]>;
    };
    growObservations: {
      params: CallContractParams<{ growTo: bigint }>;
      result: CallContractResult<null>;
    };
    getVersion: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<bigint>;
    };
    modifyLiquidityView: {
      params: CallContractParams<{ params: ModifyLiquidity }>;
      result: CallContractResult<[bigint, bigint]>;
    };
    getSqrtPriceX96: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<bigint>;
    };
    getUpdatedPosition: {
      params: CallContractParams<{ positionKey: PositionKey }>;
      result: CallContractResult<Position>;
    };
    getPosition: {
      params: CallContractParams<{ positionKey: PositionKey }>;
      result: CallContractResult<Position>;
    };
    positionExists: {
      params: CallContractParams<{ positionKey: PositionKey }>;
      result: CallContractResult<boolean>;
    };
    getTokenBalances: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<[bigint, bigint]>;
    };
    initialize: {
      params: CallContractParams<{ payer: Address; intialSqrtPrice: bigint }>;
      result: CallContractResult<null>;
    };
    modifyFeeProtocol: {
      params: CallContractParams<{ newFeeProtocol: bigint }>;
      result: CallContractResult<null>;
    };
    modifyLiquidity: {
      params: CallContractParams<{ payer: Address; params: ModifyLiquidity }>;
      result: CallContractResult<[bigint, bigint]>;
    };
    claimFees: {
      params: CallContractParams<{
        refundAddress: Address;
        positionKey: PositionKey;
      }>;
      result: CallContractResult<[bigint, bigint]>;
    };
    swap: {
      params: CallContractParams<{
        caller: Address;
        zeroForOne: boolean;
        amountSpecified: bigint;
        priceLimit: bigint;
      }>;
      result: CallContractResult<[bigint, bigint, bigint, bigint]>;
    };
    factoryOnlySubUserDeltas: {
      params: CallContractParams<{
        userDelta0: bigint;
        userDelta1: bigint;
        protocol0: bigint;
        protocol1: bigint;
      }>;
      result: CallContractResult<null>;
    };
    getMeanTick: {
      params: CallContractParams<{
        startTimestamp: bigint;
        endTimestamp: bigint;
      }>;
      result: CallContractResult<bigint>;
    };
    getObservation: {
      params: CallContractParams<{ timestamp: bigint }>;
      result: CallContractResult<ObservationCL>;
    };
    snapshotCumulativesInside: {
      params: CallContractParams<{ tickLower: bigint; tickUpper: bigint }>;
      result: CallContractResult<[bigint, bigint, bigint]>;
    };
    log2: {
      params: CallContractParams<{ x96: bigint }>;
      result: CallContractResult<bigint>;
    };
    getSqrtRatioAtTick: {
      params: CallContractParams<{ tick: bigint }>;
      result: CallContractResult<bigint>;
    };
    getTickAtSqrtRatio: {
      params: CallContractParams<{ ratioX96: bigint }>;
      result: CallContractResult<bigint>;
    };
    abs: {
      params: CallContractParams<{ in: bigint }>;
      result: CallContractResult<bigint>;
    };
    mostSignificantBit: {
      params: CallContractParams<{ x: bigint }>;
      result: CallContractResult<bigint>;
    };
    leastSignificantBit: {
      params: CallContractParams<{ value: bigint }>;
      result: CallContractResult<bigint>;
    };
    divRoundingUp: {
      params: CallContractParams<{ num: bigint; denom: bigint }>;
      result: CallContractResult<bigint>;
    };
    check160: {
      params: CallContractParams<{ x: bigint }>;
      result: CallContractResult<bigint>;
    };
    getNextSqrtPriceFromAmount0RoundingUp: {
      params: CallContractParams<{
        sqrtPX96: bigint;
        liquidity: bigint;
        amount: bigint;
        add: boolean;
      }>;
      result: CallContractResult<bigint>;
    };
    getNextSqrtPriceFromAmount1RoundingDown: {
      params: CallContractParams<{
        sqrtPX96: bigint;
        liquidity: bigint;
        amount: bigint;
        add: boolean;
      }>;
      result: CallContractResult<bigint>;
    };
    getNextSqrtPriceFromInput: {
      params: CallContractParams<{
        sqrtPX96: bigint;
        liquidity: bigint;
        amountIn: bigint;
        zeroForOne: boolean;
      }>;
      result: CallContractResult<bigint>;
    };
    getNextSqrtPriceFromOutput: {
      params: CallContractParams<{
        sqrtPX96: bigint;
        liquidity: bigint;
        amountOut: bigint;
        zeroForOne: boolean;
      }>;
      result: CallContractResult<bigint>;
    };
    getAmount0Delta: {
      params: CallContractParams<{
        sqrtRatioAX96: bigint;
        sqrtRatioBX96: bigint;
        liquidity: bigint;
        roundUp: boolean;
      }>;
      result: CallContractResult<bigint>;
    };
    getAmount1Delta: {
      params: CallContractParams<{
        sqrtRatioAX96: bigint;
        sqrtRatioBX96: bigint;
        liquidity: bigint;
        roundUp: boolean;
      }>;
      result: CallContractResult<bigint>;
    };
    getAmount0DeltaAuto: {
      params: CallContractParams<{
        sqrtRatioAX96: bigint;
        sqrtRatioBX96: bigint;
        liquidity: bigint;
      }>;
      result: CallContractResult<bigint>;
    };
    getAmount1DeltaAuto: {
      params: CallContractParams<{
        sqrtRatioAX96: bigint;
        sqrtRatioBX96: bigint;
        liquidity: bigint;
      }>;
      result: CallContractResult<bigint>;
    };
    mulDiv: {
      params: CallContractParams<{ a: bigint; b: bigint; denom: bigint }>;
      result: CallContractResult<bigint>;
    };
    mulDivCeil: {
      params: CallContractParams<{ a: bigint; b: bigint; denom: bigint }>;
      result: CallContractResult<bigint>;
    };
    getOrCreateTick: {
      params: CallContractParams<{ payer: Address; tick: bigint }>;
      result: CallContractResult<TickInfo>;
    };
    getFeeGrowthInside: {
      params: CallContractParams<{
        tickLower: bigint;
        tickUpper: bigint;
        currentPoolInfo: CurrentPoolInfo;
      }>;
      result: CallContractResult<[bigint, bigint]>;
    };
    updateTick: {
      params: CallContractParams<{
        payer: Address;
        tick: bigint;
        liquidityDelta: bigint;
        upper: boolean;
        currentPoolInfo: CurrentPoolInfo;
        observation: ObservationCL;
      }>;
      result: CallContractResult<TickUpdateInfo>;
    };
    clearTick: {
      params: CallContractParams<{ recipient: Address; tick: bigint }>;
      result: CallContractResult<null>;
    };
    getHasFlipped: {
      params: CallContractParams<{
        newLiquidityGross: bigint;
        currentLiquidityGross: bigint;
      }>;
      result: CallContractResult<boolean>;
    };
    getLiquidityGross: {
      params: CallContractParams<{
        liquidityGross: bigint;
        liquidityDelta: bigint;
      }>;
      result: CallContractResult<bigint>;
    };
    getLiquidityNet: {
      params: CallContractParams<{
        liquidityNet: bigint;
        liquidityDelta: bigint;
        upper: boolean;
      }>;
      result: CallContractResult<bigint>;
    };
    crossTick: {
      params: CallContractParams<{
        destinationTick: bigint;
        feeGrowthGlobal0X128: bigint;
        feeGrowthGlobal1X128: bigint;
        observation: ObservationCL;
      }>;
      result: CallContractResult<bigint>;
    };
    checkTicks: {
      params: CallContractParams<{ low: bigint; high: bigint }>;
      result: CallContractResult<null>;
    };
    flipTick: {
      params: CallContractParams<{
        payer: Address;
        tickValue: bigint;
        poolTickSpacing: bigint;
      }>;
      result: CallContractResult<null>;
    };
    getNextInitializedTickWithinOneRecord: {
      params: CallContractParams<{
        tickValue: bigint;
        poolTickSpacing: bigint;
        zeroToOne: boolean;
      }>;
      result: CallContractResult<NextTick>;
    };
    getValueOrDefault: {
      params: CallContractParams<{ key: bigint }>;
      result: CallContractResult<bigint>;
    };
    compress: {
      params: CallContractParams<{
        tickValue: bigint;
        poolTickSpacing: bigint;
      }>;
      result: CallContractResult<bigint>;
    };
    getTickIndex: {
      params: CallContractParams<{
        tickValue: bigint;
        poolTickSpacing: bigint;
      }>;
      result: CallContractResult<bigint>;
    };
    getKey: {
      params: CallContractParams<{ tickIndex: bigint }>;
      result: CallContractResult<bigint>;
    };
    getOffset: {
      params: CallContractParams<{ tickIndex: bigint }>;
      result: CallContractResult<bigint>;
    };
    getNewValue: {
      params: CallContractParams<{ previousValue: bigint; offset: bigint }>;
      result: CallContractResult<bigint>;
    };
    createPositionIfNotExists: {
      params: CallContractParams<{
        positionInitializer: Address;
        positionKey: PositionKey;
      }>;
      result: CallContractResult<null>;
    };
    updatePosition: {
      params: CallContractParams<{
        refundAddress: Address;
        positionKey: PositionKey;
        liquidityDelta: bigint;
        feeGrowthInside0X128: bigint;
        feeGrowthInside1X128: bigint;
        claimFee: boolean;
      }>;
      result: CallContractResult<[bigint, bigint]>;
    };
    updatePositionInstance: {
      params: CallContractParams<{
        position: Position;
        liquidityDelta: bigint;
        feeGrowthInside0X128: bigint;
        feeGrowthInside1X128: bigint;
        claimFee: boolean;
      }>;
      result: CallContractResult<[Position, bigint, bigint]>;
    };
    positionToMapKey: {
      params: CallContractParams<{ positionKey: PositionKey }>;
      result: CallContractResult<HexString>;
    };
    safeUpdateLiqudity: {
      params: CallContractParams<{
        currentLiqudity: bigint;
        liquidityDelta: bigint;
      }>;
      result: CallContractResult<bigint>;
    };
    calculateAccumulatedFee: {
      params: CallContractParams<{
        liqudity: bigint;
        currentFeeGrowthInsideX128: bigint;
        feeGrowthInsideLastX128: bigint;
      }>;
      result: CallContractResult<bigint>;
    };
    encodeObservation: {
      params: CallContractParams<{ observation: ObservationCL }>;
      result: CallContractResult<HexString>;
    };
    decodeObservation: {
      params: CallContractParams<{
        encodedObservations: HexString;
        index: bigint;
      }>;
      result: CallContractResult<ObservationCL>;
    };
    initializeObservations: {
      params: CallContractParams<{ payer: Address }>;
      result: CallContractResult<null>;
    };
    transformObservation: {
      params: CallContractParams<{
        observation: ObservationCL;
        timestamp: bigint;
      }>;
      result: CallContractResult<ObservationCL>;
    };
    writeObservation: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<null>;
    };
    innerSearchObservations: {
      params: CallContractParams<{
        timestamp: bigint;
        encodedObservations: HexString;
        beforeOrAt: ObservationCL;
        atOrAfter: ObservationCL;
      }>;
      result: CallContractResult<[ObservationCL, ObservationCL]>;
    };
    binarySearchObservations: {
      params: CallContractParams<{ timestamp: bigint }>;
      result: CallContractResult<[ObservationCL, ObservationCL]>;
    };
    interpolateObservations: {
      params: CallContractParams<{
        timestamp: bigint;
        a: ObservationCL;
        b: ObservationCL;
      }>;
      result: CallContractResult<ObservationCL>;
    };
    runSwapSteps: {
      params: CallContractParams<{
        zeroForOne: boolean;
        amountSpecified: bigint;
        priceLimit: bigint;
      }>;
      result: CallContractResult<
        [bigint, bigint, bigint, bigint, bigint, bigint, bigint]
      >;
    };
    clampToTargetPrice: {
      params: CallContractParams<{
        zeroForOne: boolean;
        nextPrice: bigint;
        priceLimit: bigint;
      }>;
      result: CallContractResult<bigint>;
    };
    calcSwapStep: {
      params: CallContractParams<{
        zeroForOne: boolean;
        amountRemaining: bigint;
        currentPrice: bigint;
        targetPrice: bigint;
        currentLiquidity: bigint;
      }>;
      result: CallContractResult<[bigint, bigint, bigint, bigint]>;
    };
    updateGlobalFees: {
      params: CallContractParams<{
        zeroForOne: boolean;
        feeGrowthGlobalX128: bigint;
        amountToProtocol: bigint;
      }>;
      result: CallContractResult<null>;
    };
    upgrade: {
      params: CallContractParams<{ newCode: HexString }>;
      result: CallContractResult<null>;
    };
    setUnlocked: {
      params: CallContractParams<{ value: boolean }>;
      result: CallContractResult<null>;
    };
    postUpgradeTick: {
      params: CallContractParams<{ tickIndex: bigint }>;
      result: CallContractResult<null>;
    };
  }
  export type CallMethodParams<T extends keyof CallMethodTable> =
    CallMethodTable[T]["params"];
  export type CallMethodResult<T extends keyof CallMethodTable> =
    CallMethodTable[T]["result"];
  export type MultiCallParams = Partial<{
    [Name in keyof CallMethodTable]: CallMethodTable[Name]["params"];
  }>;
  export type MultiCallResults<T extends MultiCallParams> = {
    [MaybeName in keyof T]: MaybeName extends keyof CallMethodTable
    ? CallMethodTable[MaybeName]["result"]
    : undefined;
  };
  export type MulticallReturnType<Callss extends MultiCallParams[]> = {
    [index in keyof Callss]: MultiCallResults<Callss[index]>;
  };

  export interface SignExecuteMethodTable {
    getTWAP: {
      params: SignExecuteContractMethodParams<{
        token: HexString;
        startTimestamp: bigint;
        endTimestamp: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    growObservations: {
      params: SignExecuteContractMethodParams<{ growTo: bigint }>;
      result: SignExecuteScriptTxResult;
    };
    getVersion: {
      params: Omit<SignExecuteContractMethodParams<{}>, "args">;
      result: SignExecuteScriptTxResult;
    };
    modifyLiquidityView: {
      params: SignExecuteContractMethodParams<{ params: ModifyLiquidity }>;
      result: SignExecuteScriptTxResult;
    };
    getSqrtPriceX96: {
      params: Omit<SignExecuteContractMethodParams<{}>, "args">;
      result: SignExecuteScriptTxResult;
    };
    getUpdatedPosition: {
      params: SignExecuteContractMethodParams<{ positionKey: PositionKey }>;
      result: SignExecuteScriptTxResult;
    };
    getPosition: {
      params: SignExecuteContractMethodParams<{ positionKey: PositionKey }>;
      result: SignExecuteScriptTxResult;
    };
    positionExists: {
      params: SignExecuteContractMethodParams<{ positionKey: PositionKey }>;
      result: SignExecuteScriptTxResult;
    };
    getTokenBalances: {
      params: Omit<SignExecuteContractMethodParams<{}>, "args">;
      result: SignExecuteScriptTxResult;
    };
    initialize: {
      params: SignExecuteContractMethodParams<{
        payer: Address;
        intialSqrtPrice: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    modifyFeeProtocol: {
      params: SignExecuteContractMethodParams<{ newFeeProtocol: bigint }>;
      result: SignExecuteScriptTxResult;
    };
    modifyLiquidity: {
      params: SignExecuteContractMethodParams<{
        payer: Address;
        params: ModifyLiquidity;
      }>;
      result: SignExecuteScriptTxResult;
    };
    claimFees: {
      params: SignExecuteContractMethodParams<{
        refundAddress: Address;
        positionKey: PositionKey;
      }>;
      result: SignExecuteScriptTxResult;
    };
    swap: {
      params: SignExecuteContractMethodParams<{
        caller: Address;
        zeroForOne: boolean;
        amountSpecified: bigint;
        priceLimit: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    factoryOnlySubUserDeltas: {
      params: SignExecuteContractMethodParams<{
        userDelta0: bigint;
        userDelta1: bigint;
        protocol0: bigint;
        protocol1: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    getMeanTick: {
      params: SignExecuteContractMethodParams<{
        startTimestamp: bigint;
        endTimestamp: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    getObservation: {
      params: SignExecuteContractMethodParams<{ timestamp: bigint }>;
      result: SignExecuteScriptTxResult;
    };
    snapshotCumulativesInside: {
      params: SignExecuteContractMethodParams<{
        tickLower: bigint;
        tickUpper: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    log2: {
      params: SignExecuteContractMethodParams<{ x96: bigint }>;
      result: SignExecuteScriptTxResult;
    };
    getSqrtRatioAtTick: {
      params: SignExecuteContractMethodParams<{ tick: bigint }>;
      result: SignExecuteScriptTxResult;
    };
    getTickAtSqrtRatio: {
      params: SignExecuteContractMethodParams<{ ratioX96: bigint }>;
      result: SignExecuteScriptTxResult;
    };
    abs: {
      params: SignExecuteContractMethodParams<{ in: bigint }>;
      result: SignExecuteScriptTxResult;
    };
    mostSignificantBit: {
      params: SignExecuteContractMethodParams<{ x: bigint }>;
      result: SignExecuteScriptTxResult;
    };
    leastSignificantBit: {
      params: SignExecuteContractMethodParams<{ value: bigint }>;
      result: SignExecuteScriptTxResult;
    };
    divRoundingUp: {
      params: SignExecuteContractMethodParams<{ num: bigint; denom: bigint }>;
      result: SignExecuteScriptTxResult;
    };
    check160: {
      params: SignExecuteContractMethodParams<{ x: bigint }>;
      result: SignExecuteScriptTxResult;
    };
    getNextSqrtPriceFromAmount0RoundingUp: {
      params: SignExecuteContractMethodParams<{
        sqrtPX96: bigint;
        liquidity: bigint;
        amount: bigint;
        add: boolean;
      }>;
      result: SignExecuteScriptTxResult;
    };
    getNextSqrtPriceFromAmount1RoundingDown: {
      params: SignExecuteContractMethodParams<{
        sqrtPX96: bigint;
        liquidity: bigint;
        amount: bigint;
        add: boolean;
      }>;
      result: SignExecuteScriptTxResult;
    };
    getNextSqrtPriceFromInput: {
      params: SignExecuteContractMethodParams<{
        sqrtPX96: bigint;
        liquidity: bigint;
        amountIn: bigint;
        zeroForOne: boolean;
      }>;
      result: SignExecuteScriptTxResult;
    };
    getNextSqrtPriceFromOutput: {
      params: SignExecuteContractMethodParams<{
        sqrtPX96: bigint;
        liquidity: bigint;
        amountOut: bigint;
        zeroForOne: boolean;
      }>;
      result: SignExecuteScriptTxResult;
    };
    getAmount0Delta: {
      params: SignExecuteContractMethodParams<{
        sqrtRatioAX96: bigint;
        sqrtRatioBX96: bigint;
        liquidity: bigint;
        roundUp: boolean;
      }>;
      result: SignExecuteScriptTxResult;
    };
    getAmount1Delta: {
      params: SignExecuteContractMethodParams<{
        sqrtRatioAX96: bigint;
        sqrtRatioBX96: bigint;
        liquidity: bigint;
        roundUp: boolean;
      }>;
      result: SignExecuteScriptTxResult;
    };
    getAmount0DeltaAuto: {
      params: SignExecuteContractMethodParams<{
        sqrtRatioAX96: bigint;
        sqrtRatioBX96: bigint;
        liquidity: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    getAmount1DeltaAuto: {
      params: SignExecuteContractMethodParams<{
        sqrtRatioAX96: bigint;
        sqrtRatioBX96: bigint;
        liquidity: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    mulDiv: {
      params: SignExecuteContractMethodParams<{
        a: bigint;
        b: bigint;
        denom: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    mulDivCeil: {
      params: SignExecuteContractMethodParams<{
        a: bigint;
        b: bigint;
        denom: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    getOrCreateTick: {
      params: SignExecuteContractMethodParams<{ payer: Address; tick: bigint }>;
      result: SignExecuteScriptTxResult;
    };
    getFeeGrowthInside: {
      params: SignExecuteContractMethodParams<{
        tickLower: bigint;
        tickUpper: bigint;
        currentPoolInfo: CurrentPoolInfo;
      }>;
      result: SignExecuteScriptTxResult;
    };
    updateTick: {
      params: SignExecuteContractMethodParams<{
        payer: Address;
        tick: bigint;
        liquidityDelta: bigint;
        upper: boolean;
        currentPoolInfo: CurrentPoolInfo;
        observation: ObservationCL;
      }>;
      result: SignExecuteScriptTxResult;
    };
    clearTick: {
      params: SignExecuteContractMethodParams<{
        recipient: Address;
        tick: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    getHasFlipped: {
      params: SignExecuteContractMethodParams<{
        newLiquidityGross: bigint;
        currentLiquidityGross: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    getLiquidityGross: {
      params: SignExecuteContractMethodParams<{
        liquidityGross: bigint;
        liquidityDelta: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    getLiquidityNet: {
      params: SignExecuteContractMethodParams<{
        liquidityNet: bigint;
        liquidityDelta: bigint;
        upper: boolean;
      }>;
      result: SignExecuteScriptTxResult;
    };
    crossTick: {
      params: SignExecuteContractMethodParams<{
        destinationTick: bigint;
        feeGrowthGlobal0X128: bigint;
        feeGrowthGlobal1X128: bigint;
        observation: ObservationCL;
      }>;
      result: SignExecuteScriptTxResult;
    };
    checkTicks: {
      params: SignExecuteContractMethodParams<{ low: bigint; high: bigint }>;
      result: SignExecuteScriptTxResult;
    };
    flipTick: {
      params: SignExecuteContractMethodParams<{
        payer: Address;
        tickValue: bigint;
        poolTickSpacing: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    getNextInitializedTickWithinOneRecord: {
      params: SignExecuteContractMethodParams<{
        tickValue: bigint;
        poolTickSpacing: bigint;
        zeroToOne: boolean;
      }>;
      result: SignExecuteScriptTxResult;
    };
    getValueOrDefault: {
      params: SignExecuteContractMethodParams<{ key: bigint }>;
      result: SignExecuteScriptTxResult;
    };
    compress: {
      params: SignExecuteContractMethodParams<{
        tickValue: bigint;
        poolTickSpacing: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    getTickIndex: {
      params: SignExecuteContractMethodParams<{
        tickValue: bigint;
        poolTickSpacing: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    getKey: {
      params: SignExecuteContractMethodParams<{ tickIndex: bigint }>;
      result: SignExecuteScriptTxResult;
    };
    getOffset: {
      params: SignExecuteContractMethodParams<{ tickIndex: bigint }>;
      result: SignExecuteScriptTxResult;
    };
    getNewValue: {
      params: SignExecuteContractMethodParams<{
        previousValue: bigint;
        offset: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    createPositionIfNotExists: {
      params: SignExecuteContractMethodParams<{
        positionInitializer: Address;
        positionKey: PositionKey;
      }>;
      result: SignExecuteScriptTxResult;
    };
    updatePosition: {
      params: SignExecuteContractMethodParams<{
        refundAddress: Address;
        positionKey: PositionKey;
        liquidityDelta: bigint;
        feeGrowthInside0X128: bigint;
        feeGrowthInside1X128: bigint;
        claimFee: boolean;
      }>;
      result: SignExecuteScriptTxResult;
    };
    updatePositionInstance: {
      params: SignExecuteContractMethodParams<{
        position: Position;
        liquidityDelta: bigint;
        feeGrowthInside0X128: bigint;
        feeGrowthInside1X128: bigint;
        claimFee: boolean;
      }>;
      result: SignExecuteScriptTxResult;
    };
    positionToMapKey: {
      params: SignExecuteContractMethodParams<{ positionKey: PositionKey }>;
      result: SignExecuteScriptTxResult;
    };
    safeUpdateLiqudity: {
      params: SignExecuteContractMethodParams<{
        currentLiqudity: bigint;
        liquidityDelta: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    calculateAccumulatedFee: {
      params: SignExecuteContractMethodParams<{
        liqudity: bigint;
        currentFeeGrowthInsideX128: bigint;
        feeGrowthInsideLastX128: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    encodeObservation: {
      params: SignExecuteContractMethodParams<{ observation: ObservationCL }>;
      result: SignExecuteScriptTxResult;
    };
    decodeObservation: {
      params: SignExecuteContractMethodParams<{
        encodedObservations: HexString;
        index: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    initializeObservations: {
      params: SignExecuteContractMethodParams<{ payer: Address }>;
      result: SignExecuteScriptTxResult;
    };
    transformObservation: {
      params: SignExecuteContractMethodParams<{
        observation: ObservationCL;
        timestamp: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    writeObservation: {
      params: Omit<SignExecuteContractMethodParams<{}>, "args">;
      result: SignExecuteScriptTxResult;
    };
    innerSearchObservations: {
      params: SignExecuteContractMethodParams<{
        timestamp: bigint;
        encodedObservations: HexString;
        beforeOrAt: ObservationCL;
        atOrAfter: ObservationCL;
      }>;
      result: SignExecuteScriptTxResult;
    };
    binarySearchObservations: {
      params: SignExecuteContractMethodParams<{ timestamp: bigint }>;
      result: SignExecuteScriptTxResult;
    };
    interpolateObservations: {
      params: SignExecuteContractMethodParams<{
        timestamp: bigint;
        a: ObservationCL;
        b: ObservationCL;
      }>;
      result: SignExecuteScriptTxResult;
    };
    runSwapSteps: {
      params: SignExecuteContractMethodParams<{
        zeroForOne: boolean;
        amountSpecified: bigint;
        priceLimit: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    clampToTargetPrice: {
      params: SignExecuteContractMethodParams<{
        zeroForOne: boolean;
        nextPrice: bigint;
        priceLimit: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    calcSwapStep: {
      params: SignExecuteContractMethodParams<{
        zeroForOne: boolean;
        amountRemaining: bigint;
        currentPrice: bigint;
        targetPrice: bigint;
        currentLiquidity: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    updateGlobalFees: {
      params: SignExecuteContractMethodParams<{
        zeroForOne: boolean;
        feeGrowthGlobalX128: bigint;
        amountToProtocol: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    upgrade: {
      params: SignExecuteContractMethodParams<{ newCode: HexString }>;
      result: SignExecuteScriptTxResult;
    };
    setUnlocked: {
      params: SignExecuteContractMethodParams<{ value: boolean }>;
      result: SignExecuteScriptTxResult;
    };
    postUpgradeTick: {
      params: SignExecuteContractMethodParams<{ tickIndex: bigint }>;
      result: SignExecuteScriptTxResult;
    };
  }
  export type SignExecuteMethodParams<T extends keyof SignExecuteMethodTable> =
    SignExecuteMethodTable[T]["params"];
  export type SignExecuteMethodResult<T extends keyof SignExecuteMethodTable> =
    SignExecuteMethodTable[T]["result"];

  export type Maps = {
    ticks?: Map<bigint, TickInfo>;
    tickBitmap?: Map<bigint, bigint>;
    providersPositions?: Map<HexString, Position>;
    observations?: Map<bigint, HexString>;
  };
}

class Factory extends ContractFactory<PoolCLInstance, PoolCLTypes.Fields> {
  encodeFields(fields: PoolCLTypes.Fields) {
    return encodeContractFields(
      addStdIdToFields(this.contract, fields),
      this.contract.fieldsSig,
      AllStructs
    );
  }

  eventIndex = { Swap: 0, ModifyLiquidity: 1 };
  consts = {
    MinTick: BigInt("-887272"),
    MaxTick: BigInt("887272"),
    HalfUnitX96: BigInt("39614081257132168796771975168"),
    UnitX96: BigInt("79228162514264337593543950336"),
    UnitX128: BigInt("340282366920938463463374607431768211456"),
    DoubleUnitX96: BigInt("158456325028528675187087900672"),
    U160Limit: BigInt("1461501637330902918203684832716283019655932542976"),
    MaxFee: BigInt("1000000"),
    MinSqrtPrice: BigInt("4295128739"),
    MaxSqrtPrice: BigInt("1461446703485210103287273052203988822378723970342"),
    LogPrecision: BigInt("15"),
    MinSqrtRatio: BigInt("4295128739"),
    MaxSqrtRatio: BigInt("1461446703485210103287273052203988822378723970342"),
    ObservationSize: BigInt("32"),
    ObservationsCapacity: BigInt("2048"),
    Version: BigInt("2"),
    ErrorCodes: {
      NotAdmin: BigInt("100"),
      NotNewAdmin: BigInt("101"),
      NotDeployer: BigInt("102"),
      NotInitialized: BigInt("103"),
      NotFactory: BigInt("104"),
      TokensNotSorted: BigInt("105"),
      FeeTooHigh: BigInt("106"),
      TickSpacingZero: BigInt("107"),
      NotFeeSetter: BigInt("108"),
      InvalidFeeAndSpacing: BigInt("109"),
      NotUpgrader: BigInt("110"),
      UpgradeInProgress: BigInt("111"),
      MigrateTokenIdsSizeInvalid: BigInt("112"),
      IdenticalTokenIds: BigInt("200"),
      TickOOB: BigInt("201"),
      SqrtRatioOOB: BigInt("202"),
      ProductOverflow: BigInt("203"),
      SqrtPriceTooLow: BigInt("204"),
      SqrtPriceZero: BigInt("205"),
      LiquidityZero: BigInt("206"),
      ResultExceeds160Bits: BigInt("207"),
      TickTooLow: BigInt("208"),
      TickTooHigh: BigInt("209"),
      TicksUnordered: BigInt("210"),
      TokenIdsSizeInvalid: BigInt("211"),
      TickNotMultipleOfSpacing: BigInt("212"),
      TickSpacingNonPositive: BigInt("213"),
      LowerTickNotMultiple: BigInt("214"),
      UpperTickNotMultiple: BigInt("215"),
      PriceLimitOOB: BigInt("216"),
      TickUninitialized: BigInt("217"),
      TokenNotInPool: BigInt("218"),
      PositionIsStaked: BigInt("219"),
      PoolLocked: BigInt("220"),
      InvariantNotConverged: BigInt("300"),
      BalanceUpdateNotConverged: BigInt("301"),
      CoinIndexOutOfBounds: BigInt("302"),
      SameCoinIndices: BigInt("303"),
      IncorrectTokenIndex: BigInt("800"),
      NFTNotFound: BigInt("801"),
      NFTNotPartOfCollection: BigInt("802"),
      MissingNFTInput: BigInt("803"),
      NFTUpgradeSameVersion: BigInt("804"),
      NFTUpgradeBadCodeHash: BigInt("805"),
      IncentiveRewardZero: BigInt("810"),
      IncentiveStartTimeTooEarly: BigInt("811"),
      StartTimeAfterEndTime: BigInt("812"),
      StartTimeTooFarInTheFuture: BigInt("813"),
      IncentiveDurationTooLong: BigInt("814"),
      NotNFTPositionManager: BigInt("815"),
      StakeNotFound: BigInt("816"),
      TooManyStakes: BigInt("817"),
      StakeAlreadyExists: BigInt("818"),
      EmptyStakeNotAllowed: BigInt("819"),
      TooEarlyToStake: BigInt("820"),
      TooLateToStake: BigInt("821"),
      IncentiveNotFound: BigInt("822"),
      MinimumAmountOutNotReached: BigInt("900"),
      UnknownPoolType: BigInt("901"),
      UnsupportedPoolType: BigInt("902"),
    },
  };

  at(address: string): PoolCLInstance {
    return new PoolCLInstance(address);
  }

  tests = {
    getTWAP: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { token: HexString; startTimestamp: bigint; endTimestamp: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<[bigint, bigint], PoolCLTypes.Maps>> => {
      return testMethod(this, "getTWAP", params, getContractByCodeHash);
    },
    growObservations: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { growTo: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<null, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "growObservations",
        params,
        getContractByCodeHash
      );
    },
    getVersion: async (
      params: Omit<
        TestContractParams<PoolCLTypes.Fields, never, PoolCLTypes.Maps>,
        "testArgs"
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(this, "getVersion", params, getContractByCodeHash);
    },
    modifyLiquidityView: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { params: ModifyLiquidity },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<[bigint, bigint], PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "modifyLiquidityView",
        params,
        getContractByCodeHash
      );
    },
    getSqrtPriceX96: async (
      params: Omit<
        TestContractParams<PoolCLTypes.Fields, never, PoolCLTypes.Maps>,
        "testArgs"
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(this, "getSqrtPriceX96", params, getContractByCodeHash);
    },
    getUpdatedPosition: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { positionKey: PositionKey },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<Position, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "getUpdatedPosition",
        params,
        getContractByCodeHash
      );
    },
    getPosition: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { positionKey: PositionKey },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<Position, PoolCLTypes.Maps>> => {
      return testMethod(this, "getPosition", params, getContractByCodeHash);
    },
    positionExists: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { positionKey: PositionKey },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<boolean, PoolCLTypes.Maps>> => {
      return testMethod(this, "positionExists", params, getContractByCodeHash);
    },
    getTokenBalances: async (
      params: Omit<
        TestContractParams<PoolCLTypes.Fields, never, PoolCLTypes.Maps>,
        "testArgs"
      >
    ): Promise<TestContractResult<[bigint, bigint], PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "getTokenBalances",
        params,
        getContractByCodeHash
      );
    },
    initialize: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { payer: Address; intialSqrtPrice: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<null, PoolCLTypes.Maps>> => {
      return testMethod(this, "initialize", params, getContractByCodeHash);
    },
    modifyFeeProtocol: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { newFeeProtocol: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<null, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "modifyFeeProtocol",
        params,
        getContractByCodeHash
      );
    },
    modifyLiquidity: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { payer: Address; params: ModifyLiquidity },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<[bigint, bigint], PoolCLTypes.Maps>> => {
      return testMethod(this, "modifyLiquidity", params, getContractByCodeHash);
    },
    claimFees: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { refundAddress: Address; positionKey: PositionKey },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<[bigint, bigint], PoolCLTypes.Maps>> => {
      return testMethod(this, "claimFees", params, getContractByCodeHash);
    },
    swap: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        {
          caller: Address;
          zeroForOne: boolean;
          amountSpecified: bigint;
          priceLimit: bigint;
        },
        PoolCLTypes.Maps
      >
    ): Promise<
      TestContractResult<[bigint, bigint, bigint, bigint], PoolCLTypes.Maps>
    > => {
      return testMethod(this, "swap", params, getContractByCodeHash);
    },
    factoryOnlySubUserDeltas: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        {
          userDelta0: bigint;
          userDelta1: bigint;
          protocol0: bigint;
          protocol1: bigint;
        },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<null, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "factoryOnlySubUserDeltas",
        params,
        getContractByCodeHash
      );
    },
    getMeanTick: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { startTimestamp: bigint; endTimestamp: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(this, "getMeanTick", params, getContractByCodeHash);
    },
    getObservation: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { timestamp: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<ObservationCL, PoolCLTypes.Maps>> => {
      return testMethod(this, "getObservation", params, getContractByCodeHash);
    },
    snapshotCumulativesInside: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { tickLower: bigint; tickUpper: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<
      TestContractResult<[bigint, bigint, bigint], PoolCLTypes.Maps>
    > => {
      return testMethod(
        this,
        "snapshotCumulativesInside",
        params,
        getContractByCodeHash
      );
    },
    log2: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { x96: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(this, "log2", params, getContractByCodeHash);
    },
    getSqrtRatioAtTick: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { tick: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "getSqrtRatioAtTick",
        params,
        getContractByCodeHash
      );
    },
    getTickAtSqrtRatio: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { ratioX96: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "getTickAtSqrtRatio",
        params,
        getContractByCodeHash
      );
    },
    abs: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { in: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(this, "abs", params, getContractByCodeHash);
    },
    mostSignificantBit: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { x: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "mostSignificantBit",
        params,
        getContractByCodeHash
      );
    },
    leastSignificantBit: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { value: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "leastSignificantBit",
        params,
        getContractByCodeHash
      );
    },
    divRoundingUp: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { num: bigint; denom: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(this, "divRoundingUp", params, getContractByCodeHash);
    },
    check160: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { x: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(this, "check160", params, getContractByCodeHash);
    },
    getNextSqrtPriceFromAmount0RoundingUp: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { sqrtPX96: bigint; liquidity: bigint; amount: bigint; add: boolean },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "getNextSqrtPriceFromAmount0RoundingUp",
        params,
        getContractByCodeHash
      );
    },
    getNextSqrtPriceFromAmount1RoundingDown: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { sqrtPX96: bigint; liquidity: bigint; amount: bigint; add: boolean },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "getNextSqrtPriceFromAmount1RoundingDown",
        params,
        getContractByCodeHash
      );
    },
    getNextSqrtPriceFromInput: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        {
          sqrtPX96: bigint;
          liquidity: bigint;
          amountIn: bigint;
          zeroForOne: boolean;
        },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "getNextSqrtPriceFromInput",
        params,
        getContractByCodeHash
      );
    },
    getNextSqrtPriceFromOutput: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        {
          sqrtPX96: bigint;
          liquidity: bigint;
          amountOut: bigint;
          zeroForOne: boolean;
        },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "getNextSqrtPriceFromOutput",
        params,
        getContractByCodeHash
      );
    },
    getAmount0Delta: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        {
          sqrtRatioAX96: bigint;
          sqrtRatioBX96: bigint;
          liquidity: bigint;
          roundUp: boolean;
        },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(this, "getAmount0Delta", params, getContractByCodeHash);
    },
    getAmount1Delta: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        {
          sqrtRatioAX96: bigint;
          sqrtRatioBX96: bigint;
          liquidity: bigint;
          roundUp: boolean;
        },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(this, "getAmount1Delta", params, getContractByCodeHash);
    },
    getAmount0DeltaAuto: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { sqrtRatioAX96: bigint; sqrtRatioBX96: bigint; liquidity: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "getAmount0DeltaAuto",
        params,
        getContractByCodeHash
      );
    },
    getAmount1DeltaAuto: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { sqrtRatioAX96: bigint; sqrtRatioBX96: bigint; liquidity: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "getAmount1DeltaAuto",
        params,
        getContractByCodeHash
      );
    },
    mulDiv: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { a: bigint; b: bigint; denom: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(this, "mulDiv", params, getContractByCodeHash);
    },
    mulDivCeil: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { a: bigint; b: bigint; denom: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(this, "mulDivCeil", params, getContractByCodeHash);
    },
    getOrCreateTick: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { payer: Address; tick: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<TickInfo, PoolCLTypes.Maps>> => {
      return testMethod(this, "getOrCreateTick", params, getContractByCodeHash);
    },
    getFeeGrowthInside: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        {
          tickLower: bigint;
          tickUpper: bigint;
          currentPoolInfo: CurrentPoolInfo;
        },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<[bigint, bigint], PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "getFeeGrowthInside",
        params,
        getContractByCodeHash
      );
    },
    updateTick: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        {
          payer: Address;
          tick: bigint;
          liquidityDelta: bigint;
          upper: boolean;
          currentPoolInfo: CurrentPoolInfo;
          observation: ObservationCL;
        },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<TickUpdateInfo, PoolCLTypes.Maps>> => {
      return testMethod(this, "updateTick", params, getContractByCodeHash);
    },
    clearTick: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { recipient: Address; tick: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<null, PoolCLTypes.Maps>> => {
      return testMethod(this, "clearTick", params, getContractByCodeHash);
    },
    getHasFlipped: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { newLiquidityGross: bigint; currentLiquidityGross: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<boolean, PoolCLTypes.Maps>> => {
      return testMethod(this, "getHasFlipped", params, getContractByCodeHash);
    },
    getLiquidityGross: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { liquidityGross: bigint; liquidityDelta: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "getLiquidityGross",
        params,
        getContractByCodeHash
      );
    },
    getLiquidityNet: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { liquidityNet: bigint; liquidityDelta: bigint; upper: boolean },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(this, "getLiquidityNet", params, getContractByCodeHash);
    },
    crossTick: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        {
          destinationTick: bigint;
          feeGrowthGlobal0X128: bigint;
          feeGrowthGlobal1X128: bigint;
          observation: ObservationCL;
        },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(this, "crossTick", params, getContractByCodeHash);
    },
    checkTicks: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { low: bigint; high: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<null, PoolCLTypes.Maps>> => {
      return testMethod(this, "checkTicks", params, getContractByCodeHash);
    },
    flipTick: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { payer: Address; tickValue: bigint; poolTickSpacing: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<null, PoolCLTypes.Maps>> => {
      return testMethod(this, "flipTick", params, getContractByCodeHash);
    },
    getNextInitializedTickWithinOneRecord: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { tickValue: bigint; poolTickSpacing: bigint; zeroToOne: boolean },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<NextTick, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "getNextInitializedTickWithinOneRecord",
        params,
        getContractByCodeHash
      );
    },
    getValueOrDefault: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { key: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "getValueOrDefault",
        params,
        getContractByCodeHash
      );
    },
    compress: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { tickValue: bigint; poolTickSpacing: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(this, "compress", params, getContractByCodeHash);
    },
    getTickIndex: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { tickValue: bigint; poolTickSpacing: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(this, "getTickIndex", params, getContractByCodeHash);
    },
    getKey: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { tickIndex: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(this, "getKey", params, getContractByCodeHash);
    },
    getOffset: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { tickIndex: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(this, "getOffset", params, getContractByCodeHash);
    },
    getNewValue: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { previousValue: bigint; offset: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(this, "getNewValue", params, getContractByCodeHash);
    },
    createPositionIfNotExists: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { positionInitializer: Address; positionKey: PositionKey },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<null, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "createPositionIfNotExists",
        params,
        getContractByCodeHash
      );
    },
    updatePosition: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        {
          refundAddress: Address;
          positionKey: PositionKey;
          liquidityDelta: bigint;
          feeGrowthInside0X128: bigint;
          feeGrowthInside1X128: bigint;
          claimFee: boolean;
        },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<[bigint, bigint], PoolCLTypes.Maps>> => {
      return testMethod(this, "updatePosition", params, getContractByCodeHash);
    },
    updatePositionInstance: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        {
          position: Position;
          liquidityDelta: bigint;
          feeGrowthInside0X128: bigint;
          feeGrowthInside1X128: bigint;
          claimFee: boolean;
        },
        PoolCLTypes.Maps
      >
    ): Promise<
      TestContractResult<[Position, bigint, bigint], PoolCLTypes.Maps>
    > => {
      return testMethod(
        this,
        "updatePositionInstance",
        params,
        getContractByCodeHash
      );
    },
    positionToMapKey: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { positionKey: PositionKey },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<HexString, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "positionToMapKey",
        params,
        getContractByCodeHash
      );
    },
    safeUpdateLiqudity: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { currentLiqudity: bigint; liquidityDelta: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "safeUpdateLiqudity",
        params,
        getContractByCodeHash
      );
    },
    calculateAccumulatedFee: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        {
          liqudity: bigint;
          currentFeeGrowthInsideX128: bigint;
          feeGrowthInsideLastX128: bigint;
        },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "calculateAccumulatedFee",
        params,
        getContractByCodeHash
      );
    },
    encodeObservation: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { observation: ObservationCL },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<HexString, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "encodeObservation",
        params,
        getContractByCodeHash
      );
    },
    decodeObservation: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { encodedObservations: HexString; index: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<ObservationCL, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "decodeObservation",
        params,
        getContractByCodeHash
      );
    },
    initializeObservations: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { payer: Address },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<null, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "initializeObservations",
        params,
        getContractByCodeHash
      );
    },
    transformObservation: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { observation: ObservationCL; timestamp: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<ObservationCL, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "transformObservation",
        params,
        getContractByCodeHash
      );
    },
    writeObservation: async (
      params: Omit<
        TestContractParams<PoolCLTypes.Fields, never, PoolCLTypes.Maps>,
        "testArgs"
      >
    ): Promise<TestContractResult<null, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "writeObservation",
        params,
        getContractByCodeHash
      );
    },
    innerSearchObservations: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        {
          timestamp: bigint;
          encodedObservations: HexString;
          beforeOrAt: ObservationCL;
          atOrAfter: ObservationCL;
        },
        PoolCLTypes.Maps
      >
    ): Promise<
      TestContractResult<[ObservationCL, ObservationCL], PoolCLTypes.Maps>
    > => {
      return testMethod(
        this,
        "innerSearchObservations",
        params,
        getContractByCodeHash
      );
    },
    binarySearchObservations: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { timestamp: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<
      TestContractResult<[ObservationCL, ObservationCL], PoolCLTypes.Maps>
    > => {
      return testMethod(
        this,
        "binarySearchObservations",
        params,
        getContractByCodeHash
      );
    },
    interpolateObservations: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { timestamp: bigint; a: ObservationCL; b: ObservationCL },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<ObservationCL, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "interpolateObservations",
        params,
        getContractByCodeHash
      );
    },
    runSwapSteps: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { zeroForOne: boolean; amountSpecified: bigint; priceLimit: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<
      TestContractResult<
        [bigint, bigint, bigint, bigint, bigint, bigint, bigint],
        PoolCLTypes.Maps
      >
    > => {
      return testMethod(this, "runSwapSteps", params, getContractByCodeHash);
    },
    clampToTargetPrice: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { zeroForOne: boolean; nextPrice: bigint; priceLimit: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<bigint, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "clampToTargetPrice",
        params,
        getContractByCodeHash
      );
    },
    calcSwapStep: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        {
          zeroForOne: boolean;
          amountRemaining: bigint;
          currentPrice: bigint;
          targetPrice: bigint;
          currentLiquidity: bigint;
        },
        PoolCLTypes.Maps
      >
    ): Promise<
      TestContractResult<[bigint, bigint, bigint, bigint], PoolCLTypes.Maps>
    > => {
      return testMethod(this, "calcSwapStep", params, getContractByCodeHash);
    },
    updateGlobalFees: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        {
          zeroForOne: boolean;
          feeGrowthGlobalX128: bigint;
          amountToProtocol: bigint;
        },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<null, PoolCLTypes.Maps>> => {
      return testMethod(
        this,
        "updateGlobalFees",
        params,
        getContractByCodeHash
      );
    },
    upgrade: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { newCode: HexString },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<null, PoolCLTypes.Maps>> => {
      return testMethod(this, "upgrade", params, getContractByCodeHash);
    },
    setUnlocked: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { value: boolean },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<null, PoolCLTypes.Maps>> => {
      return testMethod(this, "setUnlocked", params, getContractByCodeHash);
    },
    postUpgradeTick: async (
      params: TestContractParams<
        PoolCLTypes.Fields,
        { tickIndex: bigint },
        PoolCLTypes.Maps
      >
    ): Promise<TestContractResult<null, PoolCLTypes.Maps>> => {
      return testMethod(this, "postUpgradeTick", params, getContractByCodeHash);
    },
  };

  stateForTest(
    initFields: PoolCLTypes.Fields,
    asset?: Asset,
    address?: string,
    maps?: PoolCLTypes.Maps
  ) {
    return this.stateForTest_(initFields, asset, address, maps);
  }
}

// Use this object to test and deploy the contract
export const PoolCL = new Factory(
  Contract.fromJson(
    PoolCLContractJson,
    "=12-2+b2=2-2+bf=2-2+23=2+3=1-1=2-6+82=2-1+d=4+942=1+9422e=2-1=1-1=1-2=2-3+b=1-2=1-2=1+fd=2+8=1-1+44e1=2-2+19=2-2+f1=2-2+46=2-2+e8=2-2+f5=2-2+e9=2-2+ff=2-3=1-2+6=3-1+1=3+14c=1+8=2-2+73=2-2+f7=2-2+27=2-2+57=2-2+a6=2-2+f6=2+2=1-1=2-2+4a=2-2+2=1-3=2-2+49=2-2+1d=2-6+1b=3-5+e=2-2+14=2-1+2=2-2=1-1=1-2+0=1+3=2-1=1+43f=1-2+47e=2-2+2c=3-1+b=3-5+e=3-1+2=2-1=1+e=1+6=1+4=1-1+699=1-1+6=1+7=1+701=2-1+e=2-2+8=1-4+b=3-1+d5869=2-1=1+c=2-2+d7=2-2+3e=1+9=1-2+b=1-2+9f35=1+d0=2-4+2=1-1=1-3+c10=1-1=1+4c5=1+55=2+7=1-1=1-1=1-1+8b=2-2+ad=2-2+d35ffa=6-2+f8=161-1+5=68-2+11=38+7a7e0214696e73657274206174206d617020706174683a2000=27-1+b=8003-1+2=41-1+c=88+7a7e0214696e73657274206174206d617020706174683a2000=1139-1+b=40+7a7e021472656d6f7665206174206d617020706174683a2000=743-1+2=117-1+f=40+7a7e0214696e73657274206174206d617020706174683a2000=895-1+b=61-1+f=38+7a7e0214696e73657274206174206d617020706174683a2000=31-1+d=209-1+b=38+7a7e021472656d6f7665206174206d617020706174683a2000=847-1+9=130+7a7e0214696e73657274206174206d617020706174683a2000=3762",
    "cb72381d65a30ad54a9611e64563f7f5e29a5ed8a209a18738789300e73d1a52",
    AllStructs
  )
);
registerContract(PoolCL);

// Use this class to interact with the blockchain
export class PoolCLInstance extends ContractInstance {
  constructor(address: Address) {
    super(address);
  }

  maps = {
    ticks: new RalphMap<bigint, TickInfo>(
      PoolCL.contract,
      this.contractId,
      "ticks"
    ),
    tickBitmap: new RalphMap<bigint, bigint>(
      PoolCL.contract,
      this.contractId,
      "tickBitmap"
    ),
    providersPositions: new RalphMap<HexString, Position>(
      PoolCL.contract,
      this.contractId,
      "providersPositions"
    ),
    observations: new RalphMap<bigint, HexString>(
      PoolCL.contract,
      this.contractId,
      "observations"
    ),
  };

  async fetchState(): Promise<PoolCLTypes.State> {
    return fetchContractState(PoolCL, this);
  }

  async getContractEventsCurrentCount(): Promise<number> {
    return getContractEventsCurrentCount(this.address);
  }

  subscribeSwapEvent(
    options: EventSubscribeOptions<PoolCLTypes.SwapEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      PoolCL.contract,
      this,
      options,
      "Swap",
      fromCount
    );
  }

  subscribeModifyLiquidityEvent(
    options: EventSubscribeOptions<PoolCLTypes.ModifyLiquidityEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      PoolCL.contract,
      this,
      options,
      "ModifyLiquidity",
      fromCount
    );
  }

  subscribeAllEvents(
    options: EventSubscribeOptions<
      PoolCLTypes.SwapEvent | PoolCLTypes.ModifyLiquidityEvent
    >,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvents(PoolCL.contract, this, options, fromCount);
  }

  view = {
    getTWAP: async (
      params: PoolCLTypes.CallMethodParams<"getTWAP">
    ): Promise<PoolCLTypes.CallMethodResult<"getTWAP">> => {
      return callMethod(PoolCL, this, "getTWAP", params, getContractByCodeHash);
    },
    growObservations: async (
      params: PoolCLTypes.CallMethodParams<"growObservations">
    ): Promise<PoolCLTypes.CallMethodResult<"growObservations">> => {
      return callMethod(
        PoolCL,
        this,
        "growObservations",
        params,
        getContractByCodeHash
      );
    },
    getVersion: async (
      params?: PoolCLTypes.CallMethodParams<"getVersion">
    ): Promise<PoolCLTypes.CallMethodResult<"getVersion">> => {
      return callMethod(
        PoolCL,
        this,
        "getVersion",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    modifyLiquidityView: async (
      params: PoolCLTypes.CallMethodParams<"modifyLiquidityView">
    ): Promise<PoolCLTypes.CallMethodResult<"modifyLiquidityView">> => {
      return callMethod(
        PoolCL,
        this,
        "modifyLiquidityView",
        params,
        getContractByCodeHash
      );
    },
    getSqrtPriceX96: async (
      params?: PoolCLTypes.CallMethodParams<"getSqrtPriceX96">
    ): Promise<PoolCLTypes.CallMethodResult<"getSqrtPriceX96">> => {
      return callMethod(
        PoolCL,
        this,
        "getSqrtPriceX96",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getUpdatedPosition: async (
      params: PoolCLTypes.CallMethodParams<"getUpdatedPosition">
    ): Promise<PoolCLTypes.CallMethodResult<"getUpdatedPosition">> => {
      return callMethod(
        PoolCL,
        this,
        "getUpdatedPosition",
        params,
        getContractByCodeHash
      );
    },
    getPosition: async (
      params: PoolCLTypes.CallMethodParams<"getPosition">
    ): Promise<PoolCLTypes.CallMethodResult<"getPosition">> => {
      return callMethod(
        PoolCL,
        this,
        "getPosition",
        params,
        getContractByCodeHash
      );
    },
    positionExists: async (
      params: PoolCLTypes.CallMethodParams<"positionExists">
    ): Promise<PoolCLTypes.CallMethodResult<"positionExists">> => {
      return callMethod(
        PoolCL,
        this,
        "positionExists",
        params,
        getContractByCodeHash
      );
    },
    getTokenBalances: async (
      params?: PoolCLTypes.CallMethodParams<"getTokenBalances">
    ): Promise<PoolCLTypes.CallMethodResult<"getTokenBalances">> => {
      return callMethod(
        PoolCL,
        this,
        "getTokenBalances",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    initialize: async (
      params: PoolCLTypes.CallMethodParams<"initialize">
    ): Promise<PoolCLTypes.CallMethodResult<"initialize">> => {
      return callMethod(
        PoolCL,
        this,
        "initialize",
        params,
        getContractByCodeHash
      );
    },
    modifyFeeProtocol: async (
      params: PoolCLTypes.CallMethodParams<"modifyFeeProtocol">
    ): Promise<PoolCLTypes.CallMethodResult<"modifyFeeProtocol">> => {
      return callMethod(
        PoolCL,
        this,
        "modifyFeeProtocol",
        params,
        getContractByCodeHash
      );
    },
    modifyLiquidity: async (
      params: PoolCLTypes.CallMethodParams<"modifyLiquidity">
    ): Promise<PoolCLTypes.CallMethodResult<"modifyLiquidity">> => {
      return callMethod(
        PoolCL,
        this,
        "modifyLiquidity",
        params,
        getContractByCodeHash
      );
    },
    claimFees: async (
      params: PoolCLTypes.CallMethodParams<"claimFees">
    ): Promise<PoolCLTypes.CallMethodResult<"claimFees">> => {
      return callMethod(
        PoolCL,
        this,
        "claimFees",
        params,
        getContractByCodeHash
      );
    },
    swap: async (
      params: PoolCLTypes.CallMethodParams<"swap">
    ): Promise<PoolCLTypes.CallMethodResult<"swap">> => {
      return callMethod(PoolCL, this, "swap", params, getContractByCodeHash);
    },
    factoryOnlySubUserDeltas: async (
      params: PoolCLTypes.CallMethodParams<"factoryOnlySubUserDeltas">
    ): Promise<PoolCLTypes.CallMethodResult<"factoryOnlySubUserDeltas">> => {
      return callMethod(
        PoolCL,
        this,
        "factoryOnlySubUserDeltas",
        params,
        getContractByCodeHash
      );
    },
    getMeanTick: async (
      params: PoolCLTypes.CallMethodParams<"getMeanTick">
    ): Promise<PoolCLTypes.CallMethodResult<"getMeanTick">> => {
      return callMethod(
        PoolCL,
        this,
        "getMeanTick",
        params,
        getContractByCodeHash
      );
    },
    getObservation: async (
      params: PoolCLTypes.CallMethodParams<"getObservation">
    ): Promise<PoolCLTypes.CallMethodResult<"getObservation">> => {
      return callMethod(
        PoolCL,
        this,
        "getObservation",
        params,
        getContractByCodeHash
      );
    },
    snapshotCumulativesInside: async (
      params: PoolCLTypes.CallMethodParams<"snapshotCumulativesInside">
    ): Promise<PoolCLTypes.CallMethodResult<"snapshotCumulativesInside">> => {
      return callMethod(
        PoolCL,
        this,
        "snapshotCumulativesInside",
        params,
        getContractByCodeHash
      );
    },
    log2: async (
      params: PoolCLTypes.CallMethodParams<"log2">
    ): Promise<PoolCLTypes.CallMethodResult<"log2">> => {
      return callMethod(PoolCL, this, "log2", params, getContractByCodeHash);
    },
    getSqrtRatioAtTick: async (
      params: PoolCLTypes.CallMethodParams<"getSqrtRatioAtTick">
    ): Promise<PoolCLTypes.CallMethodResult<"getSqrtRatioAtTick">> => {
      return callMethod(
        PoolCL,
        this,
        "getSqrtRatioAtTick",
        params,
        getContractByCodeHash
      );
    },
    getTickAtSqrtRatio: async (
      params: PoolCLTypes.CallMethodParams<"getTickAtSqrtRatio">
    ): Promise<PoolCLTypes.CallMethodResult<"getTickAtSqrtRatio">> => {
      return callMethod(
        PoolCL,
        this,
        "getTickAtSqrtRatio",
        params,
        getContractByCodeHash
      );
    },
    abs: async (
      params: PoolCLTypes.CallMethodParams<"abs">
    ): Promise<PoolCLTypes.CallMethodResult<"abs">> => {
      return callMethod(PoolCL, this, "abs", params, getContractByCodeHash);
    },
    mostSignificantBit: async (
      params: PoolCLTypes.CallMethodParams<"mostSignificantBit">
    ): Promise<PoolCLTypes.CallMethodResult<"mostSignificantBit">> => {
      return callMethod(
        PoolCL,
        this,
        "mostSignificantBit",
        params,
        getContractByCodeHash
      );
    },
    leastSignificantBit: async (
      params: PoolCLTypes.CallMethodParams<"leastSignificantBit">
    ): Promise<PoolCLTypes.CallMethodResult<"leastSignificantBit">> => {
      return callMethod(
        PoolCL,
        this,
        "leastSignificantBit",
        params,
        getContractByCodeHash
      );
    },
    divRoundingUp: async (
      params: PoolCLTypes.CallMethodParams<"divRoundingUp">
    ): Promise<PoolCLTypes.CallMethodResult<"divRoundingUp">> => {
      return callMethod(
        PoolCL,
        this,
        "divRoundingUp",
        params,
        getContractByCodeHash
      );
    },
    check160: async (
      params: PoolCLTypes.CallMethodParams<"check160">
    ): Promise<PoolCLTypes.CallMethodResult<"check160">> => {
      return callMethod(
        PoolCL,
        this,
        "check160",
        params,
        getContractByCodeHash
      );
    },
    getNextSqrtPriceFromAmount0RoundingUp: async (
      params: PoolCLTypes.CallMethodParams<"getNextSqrtPriceFromAmount0RoundingUp">
    ): Promise<
      PoolCLTypes.CallMethodResult<"getNextSqrtPriceFromAmount0RoundingUp">
    > => {
      return callMethod(
        PoolCL,
        this,
        "getNextSqrtPriceFromAmount0RoundingUp",
        params,
        getContractByCodeHash
      );
    },
    getNextSqrtPriceFromAmount1RoundingDown: async (
      params: PoolCLTypes.CallMethodParams<"getNextSqrtPriceFromAmount1RoundingDown">
    ): Promise<
      PoolCLTypes.CallMethodResult<"getNextSqrtPriceFromAmount1RoundingDown">
    > => {
      return callMethod(
        PoolCL,
        this,
        "getNextSqrtPriceFromAmount1RoundingDown",
        params,
        getContractByCodeHash
      );
    },
    getNextSqrtPriceFromInput: async (
      params: PoolCLTypes.CallMethodParams<"getNextSqrtPriceFromInput">
    ): Promise<PoolCLTypes.CallMethodResult<"getNextSqrtPriceFromInput">> => {
      return callMethod(
        PoolCL,
        this,
        "getNextSqrtPriceFromInput",
        params,
        getContractByCodeHash
      );
    },
    getNextSqrtPriceFromOutput: async (
      params: PoolCLTypes.CallMethodParams<"getNextSqrtPriceFromOutput">
    ): Promise<PoolCLTypes.CallMethodResult<"getNextSqrtPriceFromOutput">> => {
      return callMethod(
        PoolCL,
        this,
        "getNextSqrtPriceFromOutput",
        params,
        getContractByCodeHash
      );
    },
    getAmount0Delta: async (
      params: PoolCLTypes.CallMethodParams<"getAmount0Delta">
    ): Promise<PoolCLTypes.CallMethodResult<"getAmount0Delta">> => {
      return callMethod(
        PoolCL,
        this,
        "getAmount0Delta",
        params,
        getContractByCodeHash
      );
    },
    getAmount1Delta: async (
      params: PoolCLTypes.CallMethodParams<"getAmount1Delta">
    ): Promise<PoolCLTypes.CallMethodResult<"getAmount1Delta">> => {
      return callMethod(
        PoolCL,
        this,
        "getAmount1Delta",
        params,
        getContractByCodeHash
      );
    },
    getAmount0DeltaAuto: async (
      params: PoolCLTypes.CallMethodParams<"getAmount0DeltaAuto">
    ): Promise<PoolCLTypes.CallMethodResult<"getAmount0DeltaAuto">> => {
      return callMethod(
        PoolCL,
        this,
        "getAmount0DeltaAuto",
        params,
        getContractByCodeHash
      );
    },
    getAmount1DeltaAuto: async (
      params: PoolCLTypes.CallMethodParams<"getAmount1DeltaAuto">
    ): Promise<PoolCLTypes.CallMethodResult<"getAmount1DeltaAuto">> => {
      return callMethod(
        PoolCL,
        this,
        "getAmount1DeltaAuto",
        params,
        getContractByCodeHash
      );
    },
    mulDiv: async (
      params: PoolCLTypes.CallMethodParams<"mulDiv">
    ): Promise<PoolCLTypes.CallMethodResult<"mulDiv">> => {
      return callMethod(PoolCL, this, "mulDiv", params, getContractByCodeHash);
    },
    mulDivCeil: async (
      params: PoolCLTypes.CallMethodParams<"mulDivCeil">
    ): Promise<PoolCLTypes.CallMethodResult<"mulDivCeil">> => {
      return callMethod(
        PoolCL,
        this,
        "mulDivCeil",
        params,
        getContractByCodeHash
      );
    },
    getOrCreateTick: async (
      params: PoolCLTypes.CallMethodParams<"getOrCreateTick">
    ): Promise<PoolCLTypes.CallMethodResult<"getOrCreateTick">> => {
      return callMethod(
        PoolCL,
        this,
        "getOrCreateTick",
        params,
        getContractByCodeHash
      );
    },
    getFeeGrowthInside: async (
      params: PoolCLTypes.CallMethodParams<"getFeeGrowthInside">
    ): Promise<PoolCLTypes.CallMethodResult<"getFeeGrowthInside">> => {
      return callMethod(
        PoolCL,
        this,
        "getFeeGrowthInside",
        params,
        getContractByCodeHash
      );
    },
    updateTick: async (
      params: PoolCLTypes.CallMethodParams<"updateTick">
    ): Promise<PoolCLTypes.CallMethodResult<"updateTick">> => {
      return callMethod(
        PoolCL,
        this,
        "updateTick",
        params,
        getContractByCodeHash
      );
    },
    clearTick: async (
      params: PoolCLTypes.CallMethodParams<"clearTick">
    ): Promise<PoolCLTypes.CallMethodResult<"clearTick">> => {
      return callMethod(
        PoolCL,
        this,
        "clearTick",
        params,
        getContractByCodeHash
      );
    },
    getHasFlipped: async (
      params: PoolCLTypes.CallMethodParams<"getHasFlipped">
    ): Promise<PoolCLTypes.CallMethodResult<"getHasFlipped">> => {
      return callMethod(
        PoolCL,
        this,
        "getHasFlipped",
        params,
        getContractByCodeHash
      );
    },
    getLiquidityGross: async (
      params: PoolCLTypes.CallMethodParams<"getLiquidityGross">
    ): Promise<PoolCLTypes.CallMethodResult<"getLiquidityGross">> => {
      return callMethod(
        PoolCL,
        this,
        "getLiquidityGross",
        params,
        getContractByCodeHash
      );
    },
    getLiquidityNet: async (
      params: PoolCLTypes.CallMethodParams<"getLiquidityNet">
    ): Promise<PoolCLTypes.CallMethodResult<"getLiquidityNet">> => {
      return callMethod(
        PoolCL,
        this,
        "getLiquidityNet",
        params,
        getContractByCodeHash
      );
    },
    crossTick: async (
      params: PoolCLTypes.CallMethodParams<"crossTick">
    ): Promise<PoolCLTypes.CallMethodResult<"crossTick">> => {
      return callMethod(
        PoolCL,
        this,
        "crossTick",
        params,
        getContractByCodeHash
      );
    },
    checkTicks: async (
      params: PoolCLTypes.CallMethodParams<"checkTicks">
    ): Promise<PoolCLTypes.CallMethodResult<"checkTicks">> => {
      return callMethod(
        PoolCL,
        this,
        "checkTicks",
        params,
        getContractByCodeHash
      );
    },
    flipTick: async (
      params: PoolCLTypes.CallMethodParams<"flipTick">
    ): Promise<PoolCLTypes.CallMethodResult<"flipTick">> => {
      return callMethod(
        PoolCL,
        this,
        "flipTick",
        params,
        getContractByCodeHash
      );
    },
    getNextInitializedTickWithinOneRecord: async (
      params: PoolCLTypes.CallMethodParams<"getNextInitializedTickWithinOneRecord">
    ): Promise<
      PoolCLTypes.CallMethodResult<"getNextInitializedTickWithinOneRecord">
    > => {
      return callMethod(
        PoolCL,
        this,
        "getNextInitializedTickWithinOneRecord",
        params,
        getContractByCodeHash
      );
    },
    getValueOrDefault: async (
      params: PoolCLTypes.CallMethodParams<"getValueOrDefault">
    ): Promise<PoolCLTypes.CallMethodResult<"getValueOrDefault">> => {
      return callMethod(
        PoolCL,
        this,
        "getValueOrDefault",
        params,
        getContractByCodeHash
      );
    },
    compress: async (
      params: PoolCLTypes.CallMethodParams<"compress">
    ): Promise<PoolCLTypes.CallMethodResult<"compress">> => {
      return callMethod(
        PoolCL,
        this,
        "compress",
        params,
        getContractByCodeHash
      );
    },
    getTickIndex: async (
      params: PoolCLTypes.CallMethodParams<"getTickIndex">
    ): Promise<PoolCLTypes.CallMethodResult<"getTickIndex">> => {
      return callMethod(
        PoolCL,
        this,
        "getTickIndex",
        params,
        getContractByCodeHash
      );
    },
    getKey: async (
      params: PoolCLTypes.CallMethodParams<"getKey">
    ): Promise<PoolCLTypes.CallMethodResult<"getKey">> => {
      return callMethod(PoolCL, this, "getKey", params, getContractByCodeHash);
    },
    getOffset: async (
      params: PoolCLTypes.CallMethodParams<"getOffset">
    ): Promise<PoolCLTypes.CallMethodResult<"getOffset">> => {
      return callMethod(
        PoolCL,
        this,
        "getOffset",
        params,
        getContractByCodeHash
      );
    },
    getNewValue: async (
      params: PoolCLTypes.CallMethodParams<"getNewValue">
    ): Promise<PoolCLTypes.CallMethodResult<"getNewValue">> => {
      return callMethod(
        PoolCL,
        this,
        "getNewValue",
        params,
        getContractByCodeHash
      );
    },
    createPositionIfNotExists: async (
      params: PoolCLTypes.CallMethodParams<"createPositionIfNotExists">
    ): Promise<PoolCLTypes.CallMethodResult<"createPositionIfNotExists">> => {
      return callMethod(
        PoolCL,
        this,
        "createPositionIfNotExists",
        params,
        getContractByCodeHash
      );
    },
    updatePosition: async (
      params: PoolCLTypes.CallMethodParams<"updatePosition">
    ): Promise<PoolCLTypes.CallMethodResult<"updatePosition">> => {
      return callMethod(
        PoolCL,
        this,
        "updatePosition",
        params,
        getContractByCodeHash
      );
    },
    updatePositionInstance: async (
      params: PoolCLTypes.CallMethodParams<"updatePositionInstance">
    ): Promise<PoolCLTypes.CallMethodResult<"updatePositionInstance">> => {
      return callMethod(
        PoolCL,
        this,
        "updatePositionInstance",
        params,
        getContractByCodeHash
      );
    },
    positionToMapKey: async (
      params: PoolCLTypes.CallMethodParams<"positionToMapKey">
    ): Promise<PoolCLTypes.CallMethodResult<"positionToMapKey">> => {
      return callMethod(
        PoolCL,
        this,
        "positionToMapKey",
        params,
        getContractByCodeHash
      );
    },
    safeUpdateLiqudity: async (
      params: PoolCLTypes.CallMethodParams<"safeUpdateLiqudity">
    ): Promise<PoolCLTypes.CallMethodResult<"safeUpdateLiqudity">> => {
      return callMethod(
        PoolCL,
        this,
        "safeUpdateLiqudity",
        params,
        getContractByCodeHash
      );
    },
    calculateAccumulatedFee: async (
      params: PoolCLTypes.CallMethodParams<"calculateAccumulatedFee">
    ): Promise<PoolCLTypes.CallMethodResult<"calculateAccumulatedFee">> => {
      return callMethod(
        PoolCL,
        this,
        "calculateAccumulatedFee",
        params,
        getContractByCodeHash
      );
    },
    encodeObservation: async (
      params: PoolCLTypes.CallMethodParams<"encodeObservation">
    ): Promise<PoolCLTypes.CallMethodResult<"encodeObservation">> => {
      return callMethod(
        PoolCL,
        this,
        "encodeObservation",
        params,
        getContractByCodeHash
      );
    },
    decodeObservation: async (
      params: PoolCLTypes.CallMethodParams<"decodeObservation">
    ): Promise<PoolCLTypes.CallMethodResult<"decodeObservation">> => {
      return callMethod(
        PoolCL,
        this,
        "decodeObservation",
        params,
        getContractByCodeHash
      );
    },
    initializeObservations: async (
      params: PoolCLTypes.CallMethodParams<"initializeObservations">
    ): Promise<PoolCLTypes.CallMethodResult<"initializeObservations">> => {
      return callMethod(
        PoolCL,
        this,
        "initializeObservations",
        params,
        getContractByCodeHash
      );
    },
    transformObservation: async (
      params: PoolCLTypes.CallMethodParams<"transformObservation">
    ): Promise<PoolCLTypes.CallMethodResult<"transformObservation">> => {
      return callMethod(
        PoolCL,
        this,
        "transformObservation",
        params,
        getContractByCodeHash
      );
    },
    writeObservation: async (
      params?: PoolCLTypes.CallMethodParams<"writeObservation">
    ): Promise<PoolCLTypes.CallMethodResult<"writeObservation">> => {
      return callMethod(
        PoolCL,
        this,
        "writeObservation",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    innerSearchObservations: async (
      params: PoolCLTypes.CallMethodParams<"innerSearchObservations">
    ): Promise<PoolCLTypes.CallMethodResult<"innerSearchObservations">> => {
      return callMethod(
        PoolCL,
        this,
        "innerSearchObservations",
        params,
        getContractByCodeHash
      );
    },
    binarySearchObservations: async (
      params: PoolCLTypes.CallMethodParams<"binarySearchObservations">
    ): Promise<PoolCLTypes.CallMethodResult<"binarySearchObservations">> => {
      return callMethod(
        PoolCL,
        this,
        "binarySearchObservations",
        params,
        getContractByCodeHash
      );
    },
    interpolateObservations: async (
      params: PoolCLTypes.CallMethodParams<"interpolateObservations">
    ): Promise<PoolCLTypes.CallMethodResult<"interpolateObservations">> => {
      return callMethod(
        PoolCL,
        this,
        "interpolateObservations",
        params,
        getContractByCodeHash
      );
    },
    runSwapSteps: async (
      params: PoolCLTypes.CallMethodParams<"runSwapSteps">
    ): Promise<PoolCLTypes.CallMethodResult<"runSwapSteps">> => {
      return callMethod(
        PoolCL,
        this,
        "runSwapSteps",
        params,
        getContractByCodeHash
      );
    },
    clampToTargetPrice: async (
      params: PoolCLTypes.CallMethodParams<"clampToTargetPrice">
    ): Promise<PoolCLTypes.CallMethodResult<"clampToTargetPrice">> => {
      return callMethod(
        PoolCL,
        this,
        "clampToTargetPrice",
        params,
        getContractByCodeHash
      );
    },
    calcSwapStep: async (
      params: PoolCLTypes.CallMethodParams<"calcSwapStep">
    ): Promise<PoolCLTypes.CallMethodResult<"calcSwapStep">> => {
      return callMethod(
        PoolCL,
        this,
        "calcSwapStep",
        params,
        getContractByCodeHash
      );
    },
    updateGlobalFees: async (
      params: PoolCLTypes.CallMethodParams<"updateGlobalFees">
    ): Promise<PoolCLTypes.CallMethodResult<"updateGlobalFees">> => {
      return callMethod(
        PoolCL,
        this,
        "updateGlobalFees",
        params,
        getContractByCodeHash
      );
    },
    upgrade: async (
      params: PoolCLTypes.CallMethodParams<"upgrade">
    ): Promise<PoolCLTypes.CallMethodResult<"upgrade">> => {
      return callMethod(PoolCL, this, "upgrade", params, getContractByCodeHash);
    },
    setUnlocked: async (
      params: PoolCLTypes.CallMethodParams<"setUnlocked">
    ): Promise<PoolCLTypes.CallMethodResult<"setUnlocked">> => {
      return callMethod(
        PoolCL,
        this,
        "setUnlocked",
        params,
        getContractByCodeHash
      );
    },
    postUpgradeTick: async (
      params: PoolCLTypes.CallMethodParams<"postUpgradeTick">
    ): Promise<PoolCLTypes.CallMethodResult<"postUpgradeTick">> => {
      return callMethod(
        PoolCL,
        this,
        "postUpgradeTick",
        params,
        getContractByCodeHash
      );
    },
  };

  transact = {
    getTWAP: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getTWAP">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"getTWAP">> => {
      return signExecuteMethod(PoolCL, this, "getTWAP", params);
    },
    growObservations: async (
      params: PoolCLTypes.SignExecuteMethodParams<"growObservations">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"growObservations">> => {
      return signExecuteMethod(PoolCL, this, "growObservations", params);
    },
    getVersion: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getVersion">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"getVersion">> => {
      return signExecuteMethod(PoolCL, this, "getVersion", params);
    },
    modifyLiquidityView: async (
      params: PoolCLTypes.SignExecuteMethodParams<"modifyLiquidityView">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"modifyLiquidityView">> => {
      return signExecuteMethod(PoolCL, this, "modifyLiquidityView", params);
    },
    getSqrtPriceX96: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getSqrtPriceX96">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"getSqrtPriceX96">> => {
      return signExecuteMethod(PoolCL, this, "getSqrtPriceX96", params);
    },
    getUpdatedPosition: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getUpdatedPosition">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"getUpdatedPosition">> => {
      return signExecuteMethod(PoolCL, this, "getUpdatedPosition", params);
    },
    getPosition: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getPosition">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"getPosition">> => {
      return signExecuteMethod(PoolCL, this, "getPosition", params);
    },
    positionExists: async (
      params: PoolCLTypes.SignExecuteMethodParams<"positionExists">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"positionExists">> => {
      return signExecuteMethod(PoolCL, this, "positionExists", params);
    },
    getTokenBalances: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getTokenBalances">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"getTokenBalances">> => {
      return signExecuteMethod(PoolCL, this, "getTokenBalances", params);
    },
    initialize: async (
      params: PoolCLTypes.SignExecuteMethodParams<"initialize">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"initialize">> => {
      return signExecuteMethod(PoolCL, this, "initialize", params);
    },
    modifyFeeProtocol: async (
      params: PoolCLTypes.SignExecuteMethodParams<"modifyFeeProtocol">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"modifyFeeProtocol">> => {
      return signExecuteMethod(PoolCL, this, "modifyFeeProtocol", params);
    },
    modifyLiquidity: async (
      params: PoolCLTypes.SignExecuteMethodParams<"modifyLiquidity">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"modifyLiquidity">> => {
      return signExecuteMethod(PoolCL, this, "modifyLiquidity", params);
    },
    claimFees: async (
      params: PoolCLTypes.SignExecuteMethodParams<"claimFees">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"claimFees">> => {
      return signExecuteMethod(PoolCL, this, "claimFees", params);
    },
    swap: async (
      params: PoolCLTypes.SignExecuteMethodParams<"swap">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"swap">> => {
      return signExecuteMethod(PoolCL, this, "swap", params);
    },
    factoryOnlySubUserDeltas: async (
      params: PoolCLTypes.SignExecuteMethodParams<"factoryOnlySubUserDeltas">
    ): Promise<
      PoolCLTypes.SignExecuteMethodResult<"factoryOnlySubUserDeltas">
    > => {
      return signExecuteMethod(
        PoolCL,
        this,
        "factoryOnlySubUserDeltas",
        params
      );
    },
    getMeanTick: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getMeanTick">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"getMeanTick">> => {
      return signExecuteMethod(PoolCL, this, "getMeanTick", params);
    },
    getObservation: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getObservation">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"getObservation">> => {
      return signExecuteMethod(PoolCL, this, "getObservation", params);
    },
    snapshotCumulativesInside: async (
      params: PoolCLTypes.SignExecuteMethodParams<"snapshotCumulativesInside">
    ): Promise<
      PoolCLTypes.SignExecuteMethodResult<"snapshotCumulativesInside">
    > => {
      return signExecuteMethod(
        PoolCL,
        this,
        "snapshotCumulativesInside",
        params
      );
    },
    log2: async (
      params: PoolCLTypes.SignExecuteMethodParams<"log2">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"log2">> => {
      return signExecuteMethod(PoolCL, this, "log2", params);
    },
    getSqrtRatioAtTick: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getSqrtRatioAtTick">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"getSqrtRatioAtTick">> => {
      return signExecuteMethod(PoolCL, this, "getSqrtRatioAtTick", params);
    },
    getTickAtSqrtRatio: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getTickAtSqrtRatio">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"getTickAtSqrtRatio">> => {
      return signExecuteMethod(PoolCL, this, "getTickAtSqrtRatio", params);
    },
    abs: async (
      params: PoolCLTypes.SignExecuteMethodParams<"abs">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"abs">> => {
      return signExecuteMethod(PoolCL, this, "abs", params);
    },
    mostSignificantBit: async (
      params: PoolCLTypes.SignExecuteMethodParams<"mostSignificantBit">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"mostSignificantBit">> => {
      return signExecuteMethod(PoolCL, this, "mostSignificantBit", params);
    },
    leastSignificantBit: async (
      params: PoolCLTypes.SignExecuteMethodParams<"leastSignificantBit">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"leastSignificantBit">> => {
      return signExecuteMethod(PoolCL, this, "leastSignificantBit", params);
    },
    divRoundingUp: async (
      params: PoolCLTypes.SignExecuteMethodParams<"divRoundingUp">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"divRoundingUp">> => {
      return signExecuteMethod(PoolCL, this, "divRoundingUp", params);
    },
    check160: async (
      params: PoolCLTypes.SignExecuteMethodParams<"check160">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"check160">> => {
      return signExecuteMethod(PoolCL, this, "check160", params);
    },
    getNextSqrtPriceFromAmount0RoundingUp: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getNextSqrtPriceFromAmount0RoundingUp">
    ): Promise<
      PoolCLTypes.SignExecuteMethodResult<"getNextSqrtPriceFromAmount0RoundingUp">
    > => {
      return signExecuteMethod(
        PoolCL,
        this,
        "getNextSqrtPriceFromAmount0RoundingUp",
        params
      );
    },
    getNextSqrtPriceFromAmount1RoundingDown: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getNextSqrtPriceFromAmount1RoundingDown">
    ): Promise<
      PoolCLTypes.SignExecuteMethodResult<"getNextSqrtPriceFromAmount1RoundingDown">
    > => {
      return signExecuteMethod(
        PoolCL,
        this,
        "getNextSqrtPriceFromAmount1RoundingDown",
        params
      );
    },
    getNextSqrtPriceFromInput: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getNextSqrtPriceFromInput">
    ): Promise<
      PoolCLTypes.SignExecuteMethodResult<"getNextSqrtPriceFromInput">
    > => {
      return signExecuteMethod(
        PoolCL,
        this,
        "getNextSqrtPriceFromInput",
        params
      );
    },
    getNextSqrtPriceFromOutput: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getNextSqrtPriceFromOutput">
    ): Promise<
      PoolCLTypes.SignExecuteMethodResult<"getNextSqrtPriceFromOutput">
    > => {
      return signExecuteMethod(
        PoolCL,
        this,
        "getNextSqrtPriceFromOutput",
        params
      );
    },
    getAmount0Delta: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getAmount0Delta">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"getAmount0Delta">> => {
      return signExecuteMethod(PoolCL, this, "getAmount0Delta", params);
    },
    getAmount1Delta: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getAmount1Delta">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"getAmount1Delta">> => {
      return signExecuteMethod(PoolCL, this, "getAmount1Delta", params);
    },
    getAmount0DeltaAuto: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getAmount0DeltaAuto">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"getAmount0DeltaAuto">> => {
      return signExecuteMethod(PoolCL, this, "getAmount0DeltaAuto", params);
    },
    getAmount1DeltaAuto: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getAmount1DeltaAuto">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"getAmount1DeltaAuto">> => {
      return signExecuteMethod(PoolCL, this, "getAmount1DeltaAuto", params);
    },
    mulDiv: async (
      params: PoolCLTypes.SignExecuteMethodParams<"mulDiv">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"mulDiv">> => {
      return signExecuteMethod(PoolCL, this, "mulDiv", params);
    },
    mulDivCeil: async (
      params: PoolCLTypes.SignExecuteMethodParams<"mulDivCeil">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"mulDivCeil">> => {
      return signExecuteMethod(PoolCL, this, "mulDivCeil", params);
    },
    getOrCreateTick: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getOrCreateTick">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"getOrCreateTick">> => {
      return signExecuteMethod(PoolCL, this, "getOrCreateTick", params);
    },
    getFeeGrowthInside: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getFeeGrowthInside">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"getFeeGrowthInside">> => {
      return signExecuteMethod(PoolCL, this, "getFeeGrowthInside", params);
    },
    updateTick: async (
      params: PoolCLTypes.SignExecuteMethodParams<"updateTick">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"updateTick">> => {
      return signExecuteMethod(PoolCL, this, "updateTick", params);
    },
    clearTick: async (
      params: PoolCLTypes.SignExecuteMethodParams<"clearTick">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"clearTick">> => {
      return signExecuteMethod(PoolCL, this, "clearTick", params);
    },
    getHasFlipped: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getHasFlipped">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"getHasFlipped">> => {
      return signExecuteMethod(PoolCL, this, "getHasFlipped", params);
    },
    getLiquidityGross: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getLiquidityGross">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"getLiquidityGross">> => {
      return signExecuteMethod(PoolCL, this, "getLiquidityGross", params);
    },
    getLiquidityNet: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getLiquidityNet">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"getLiquidityNet">> => {
      return signExecuteMethod(PoolCL, this, "getLiquidityNet", params);
    },
    crossTick: async (
      params: PoolCLTypes.SignExecuteMethodParams<"crossTick">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"crossTick">> => {
      return signExecuteMethod(PoolCL, this, "crossTick", params);
    },
    checkTicks: async (
      params: PoolCLTypes.SignExecuteMethodParams<"checkTicks">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"checkTicks">> => {
      return signExecuteMethod(PoolCL, this, "checkTicks", params);
    },
    flipTick: async (
      params: PoolCLTypes.SignExecuteMethodParams<"flipTick">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"flipTick">> => {
      return signExecuteMethod(PoolCL, this, "flipTick", params);
    },
    getNextInitializedTickWithinOneRecord: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getNextInitializedTickWithinOneRecord">
    ): Promise<
      PoolCLTypes.SignExecuteMethodResult<"getNextInitializedTickWithinOneRecord">
    > => {
      return signExecuteMethod(
        PoolCL,
        this,
        "getNextInitializedTickWithinOneRecord",
        params
      );
    },
    getValueOrDefault: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getValueOrDefault">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"getValueOrDefault">> => {
      return signExecuteMethod(PoolCL, this, "getValueOrDefault", params);
    },
    compress: async (
      params: PoolCLTypes.SignExecuteMethodParams<"compress">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"compress">> => {
      return signExecuteMethod(PoolCL, this, "compress", params);
    },
    getTickIndex: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getTickIndex">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"getTickIndex">> => {
      return signExecuteMethod(PoolCL, this, "getTickIndex", params);
    },
    getKey: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getKey">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"getKey">> => {
      return signExecuteMethod(PoolCL, this, "getKey", params);
    },
    getOffset: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getOffset">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"getOffset">> => {
      return signExecuteMethod(PoolCL, this, "getOffset", params);
    },
    getNewValue: async (
      params: PoolCLTypes.SignExecuteMethodParams<"getNewValue">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"getNewValue">> => {
      return signExecuteMethod(PoolCL, this, "getNewValue", params);
    },
    createPositionIfNotExists: async (
      params: PoolCLTypes.SignExecuteMethodParams<"createPositionIfNotExists">
    ): Promise<
      PoolCLTypes.SignExecuteMethodResult<"createPositionIfNotExists">
    > => {
      return signExecuteMethod(
        PoolCL,
        this,
        "createPositionIfNotExists",
        params
      );
    },
    updatePosition: async (
      params: PoolCLTypes.SignExecuteMethodParams<"updatePosition">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"updatePosition">> => {
      return signExecuteMethod(PoolCL, this, "updatePosition", params);
    },
    updatePositionInstance: async (
      params: PoolCLTypes.SignExecuteMethodParams<"updatePositionInstance">
    ): Promise<
      PoolCLTypes.SignExecuteMethodResult<"updatePositionInstance">
    > => {
      return signExecuteMethod(PoolCL, this, "updatePositionInstance", params);
    },
    positionToMapKey: async (
      params: PoolCLTypes.SignExecuteMethodParams<"positionToMapKey">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"positionToMapKey">> => {
      return signExecuteMethod(PoolCL, this, "positionToMapKey", params);
    },
    safeUpdateLiqudity: async (
      params: PoolCLTypes.SignExecuteMethodParams<"safeUpdateLiqudity">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"safeUpdateLiqudity">> => {
      return signExecuteMethod(PoolCL, this, "safeUpdateLiqudity", params);
    },
    calculateAccumulatedFee: async (
      params: PoolCLTypes.SignExecuteMethodParams<"calculateAccumulatedFee">
    ): Promise<
      PoolCLTypes.SignExecuteMethodResult<"calculateAccumulatedFee">
    > => {
      return signExecuteMethod(PoolCL, this, "calculateAccumulatedFee", params);
    },
    encodeObservation: async (
      params: PoolCLTypes.SignExecuteMethodParams<"encodeObservation">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"encodeObservation">> => {
      return signExecuteMethod(PoolCL, this, "encodeObservation", params);
    },
    decodeObservation: async (
      params: PoolCLTypes.SignExecuteMethodParams<"decodeObservation">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"decodeObservation">> => {
      return signExecuteMethod(PoolCL, this, "decodeObservation", params);
    },
    initializeObservations: async (
      params: PoolCLTypes.SignExecuteMethodParams<"initializeObservations">
    ): Promise<
      PoolCLTypes.SignExecuteMethodResult<"initializeObservations">
    > => {
      return signExecuteMethod(PoolCL, this, "initializeObservations", params);
    },
    transformObservation: async (
      params: PoolCLTypes.SignExecuteMethodParams<"transformObservation">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"transformObservation">> => {
      return signExecuteMethod(PoolCL, this, "transformObservation", params);
    },
    writeObservation: async (
      params: PoolCLTypes.SignExecuteMethodParams<"writeObservation">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"writeObservation">> => {
      return signExecuteMethod(PoolCL, this, "writeObservation", params);
    },
    innerSearchObservations: async (
      params: PoolCLTypes.SignExecuteMethodParams<"innerSearchObservations">
    ): Promise<
      PoolCLTypes.SignExecuteMethodResult<"innerSearchObservations">
    > => {
      return signExecuteMethod(PoolCL, this, "innerSearchObservations", params);
    },
    binarySearchObservations: async (
      params: PoolCLTypes.SignExecuteMethodParams<"binarySearchObservations">
    ): Promise<
      PoolCLTypes.SignExecuteMethodResult<"binarySearchObservations">
    > => {
      return signExecuteMethod(
        PoolCL,
        this,
        "binarySearchObservations",
        params
      );
    },
    interpolateObservations: async (
      params: PoolCLTypes.SignExecuteMethodParams<"interpolateObservations">
    ): Promise<
      PoolCLTypes.SignExecuteMethodResult<"interpolateObservations">
    > => {
      return signExecuteMethod(PoolCL, this, "interpolateObservations", params);
    },
    runSwapSteps: async (
      params: PoolCLTypes.SignExecuteMethodParams<"runSwapSteps">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"runSwapSteps">> => {
      return signExecuteMethod(PoolCL, this, "runSwapSteps", params);
    },
    clampToTargetPrice: async (
      params: PoolCLTypes.SignExecuteMethodParams<"clampToTargetPrice">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"clampToTargetPrice">> => {
      return signExecuteMethod(PoolCL, this, "clampToTargetPrice", params);
    },
    calcSwapStep: async (
      params: PoolCLTypes.SignExecuteMethodParams<"calcSwapStep">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"calcSwapStep">> => {
      return signExecuteMethod(PoolCL, this, "calcSwapStep", params);
    },
    updateGlobalFees: async (
      params: PoolCLTypes.SignExecuteMethodParams<"updateGlobalFees">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"updateGlobalFees">> => {
      return signExecuteMethod(PoolCL, this, "updateGlobalFees", params);
    },
    upgrade: async (
      params: PoolCLTypes.SignExecuteMethodParams<"upgrade">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"upgrade">> => {
      return signExecuteMethod(PoolCL, this, "upgrade", params);
    },
    setUnlocked: async (
      params: PoolCLTypes.SignExecuteMethodParams<"setUnlocked">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"setUnlocked">> => {
      return signExecuteMethod(PoolCL, this, "setUnlocked", params);
    },
    postUpgradeTick: async (
      params: PoolCLTypes.SignExecuteMethodParams<"postUpgradeTick">
    ): Promise<PoolCLTypes.SignExecuteMethodResult<"postUpgradeTick">> => {
      return signExecuteMethod(PoolCL, this, "postUpgradeTick", params);
    },
  };

  async multicall<Calls extends PoolCLTypes.MultiCallParams>(
    calls: Calls
  ): Promise<PoolCLTypes.MultiCallResults<Calls>>;
  async multicall<Callss extends PoolCLTypes.MultiCallParams[]>(
    callss: Narrow<Callss>
  ): Promise<PoolCLTypes.MulticallReturnType<Callss>>;
  async multicall<
    Callss extends PoolCLTypes.MultiCallParams | PoolCLTypes.MultiCallParams[]
  >(callss: Callss): Promise<unknown> {
    return await multicallMethods(PoolCL, this, callss, getContractByCodeHash);
  }
}
